CODEBASE AUDIT & CLEANUP (MVP MONOREPO)
We have built an MVP in a monorepo (Python FastAPI backend and Next.js/React TypeScript frontend). Now we need a comprehensive retrospective audit and cleanup of the entire codebase to ensure it's clean, robust, and ready for Phase 2 development. The goal is a well-organized repository with all tests and quality checks passing, providing a solid foundation for the next phase. Focus on the following key areas and requirements:

TESTING & COVERAGE
Verify that all tests (in the tests/ directory and elsewhere) are well-organized and thorough, meeting our coverage goals (at least 90% backend and 90% frontend coverage). Ensure tests are easy to run (via simple commands or scripts) and that all tests pass successfully. This includes unit tests, integration tests, BDD tests (using pytest-bdd), front-end tests (Jest/React Testing Library), and end-to-end tests (Playwright for E2E). If any tests are failing or missing, fix or create them to cover critical scenarios. Update any coverage configuration to consistently enforce the 85% backend threshold (note: CI may have had a lower threshold, but use 85% as the target). Ultimately, the test suite should be reliable and give confidence that the application works as intended.

END-TO-END FUNCTIONALITY
Make sure the entire user flow from frontend to backend is fully debugged and working smoothly. The application should build and deploy in a development environment without errors. Verify that the frontend and backend integrate correctly – for example, that API routes, data flow, and authentication hand-offs between React and FastAPI are functioning properly. Fix any integration issues so that the front-end and back-end communicate as expected (e.g. correct API endpoints, CORS settings, data contracts) and the system works end-to-end from the UI down to the database. Essentially, simulate a real user's interaction with the app and ensure every step works without bugs or data inconsistencies. By the end, we should be confident that a user can use the MVP as intended without hitting any runtime errors or dead-ends.

DOCUMENTATION
Ensure all documentation is up-to-date and reflects the current state of the codebase. This includes README files, developer setup instructions, installation guides, and any relevant docs/ pages. Update code comments and docstrings throughout the code to clarify non-obvious logic. If features have changed or code has been refactored during development, make sure the documentation and comments are adjusted accordingly so that any new contributor (or Phase 2 developer) can rely on the docs to understand how the system works. Every module or significant function should have clear docstrings following our style guidelines (e.g. Google or NumPy docstring style as used in the project). In short, anyone reading the repository's docs or comments should get accurate and current information. If the repository has an auto-generated API documentation (for example, a reports/api-map.md or similar), regenerate or update it so it's current with the latest code.

CODE & FILE HYGIENE
Identify and remove (or consolidate) any excess or unused code, files, or configuration that are not needed for the MVP's core functionality. This means cleaning up "dead code" (functions or modules that are never called), eliminating any TODO or FIXME comments that are no longer relevant, and deleting outdated experimental files or sample data that clutter the repo. Make sure there are no leftover credentials, secrets, or large unused assets in the repo history. Streamline the repository so that only relevant, necessary components remain, which will make the structure more understandable and maintainable. In a monorepo, it's especially important to keep the root clean and well-organized. Remove obsolete configuration files or scripts (for example, old Docker files, deprecated CI configs, etc., if they're superseded by newer ones). However, do not delete anything that is truly needed for build or deployment – double-check before removal. Also, avoid making changes to automatically generated or environment-specific files (e.g. contents of logs/, data/cache/, data/databases/backups/, frontend/.next/ build artifacts, or node_modules/) – those should typically remain untouched or are git-ignored. Focus on the actual source code and config. The end result should be a lean repository without cruft: if a file or code isn't serving a purpose for the product, it should be removed or marked for exclusion.

CODE QUALITY & STANDARDS
Ensure the codebase adheres to all our established coding standards and passes all quality checks. Apply consistent code formatting using Black (with a 88-character line length) for Python and Prettier (for JavaScript/TypeScript, as per the Next.js setup) – there should be no formatting drift. Check import ordering with isort for Python. Run linters and fix issues: for Python, address any flake8 warnings/errors (PEP8 compliance and other style issues); for the frontend, run ESLint (with the Next.js/TypeScript configuration) and fix any linting problems there as well. Verify that strict type checking is clean: run MyPy on the Python code (with strict settings) and ensure there are no type errors; likewise, the TypeScript code should have zero type errors under tsc --strict. Perform security scanning and fix any issues: run Bandit on the Python code to catch insecure patterns (and address any warnings or justify/document them if false positives), and run dependency vulnerability checks (e.g. safety or similar) to ensure no critical vulnerabilities exist in our Python requirements or Node packages. If vulnerabilities are found in dependencies, consider updating the package or adding justifications if it can't be changed. Ensure all pre-commit hooks pass: this includes any YAML/JSON/TOML linters, checks for merge conflicts, large file checks, or others that are configured in the repo. Python docstring style should be consistent (if we use a tool like pydocstyle, ensure compliance). In summary, the code should be clean, pep8/ESLint compliant, well-typed, and secure. By the end, running our full quality check suite (formatters, linters, type checkers, tests, etc.) should result in 0 errors/warnings.

ARCHITECTURE & MAINTAINABILITY
Evaluate the overall project structure and architecture for clarity and future maintainability. Since this is a monorepo, confirm that the backend and frontend parts are properly separated with clear boundaries – for example, no accidental import of backend code into the frontend or vice versa, and shared code (if any) is in an appropriate common location. There should be no unnecessary duplication of logic between services; if the frontend and backend share certain constants or types, consider centralizing them in a common library (or at least ensure they're defined consistently). Simplify or refactor any convoluted areas of code to align with best practices and to make the code more understandable. This might include breaking down overly large modules or functions into smaller, focused pieces; improving naming for clarity; or reorganizing files into more logical directories. Confirm that the architecture has no "dead ends" or overly coupled components – for instance, every module should have a clear purpose, and components should interact through well-defined interfaces or APIs. If there are any remnants of half-implemented features or stale architecture decisions that hurt maintainability, remove or refactor them. The goal is a clean architecture that follows the single-responsibility and separation-of-concerns principles, making it easy for developers to navigate and extend in Phase 2. Document any architectural changes or rationales in the docs as needed.

CI/CD PIPELINE
Make sure the GitHub Actions CI/CD pipeline is green and robust after the cleanup. All stages of the CI pipeline should succeed, which means: all tests pass on all supported environments (e.g., Python 3.10 and 3.11 as configured), coverage thresholds are met, linting and formatting checks pass (with --check modes in CI ensuring no diffs), the frontend build is successful, and security scans (Bandit, safety, etc.) report no blocking issues. If the CI workflow (.github/workflows/ci.yml) has steps enforcing coverage or other quality gates, update those configurations if needed to align with our targets (for example, if backend coverage minimum is set to 75% in CI but we require 85%, adjust it to 85%). Ensure that any artifact builds or deployment steps in CI (if any, such as Docker image builds or deployment to a dev environment) still work after your changes; fix any broken paths or scripts that the pipeline uses. Similarly, review the release workflow and data-pipeline workflow (if present) to confirm that nothing in the cleanup has broken their assumptions (for example, if we removed or renamed a script that the data pipeline uses, update the workflow accordingly). In short, the project should be continuously integratable and deployable: after your changes, a commit on the main branch should sail through CI and, if configured, be ready for release. If needed, update badges or status reports in the README or reports/status.md to reflect the passing status of the pipeline and tests.

GIT WORKFLOW & PR CONVENTIONS
Adhere to our team's branching, commit, and PR guidelines throughout this cleanup effort. Use a branch name following the pattern bg/<task>-<date> for your work (for example, bg/code-cleanup-2025-08-08). Keep the scope of each commit or pull request focused – if feasible, break the cleanup into multiple PRs grouped by concern (e.g., one PR purely for formatting and lint fixes, another for removing dead code, etc.) so that each can be reviewed in isolation. Never mix unrelated changes in one commit/PR. Apply the label chore(format-only) to any purely formatting/style PRs, and use the bg-agent label to mark that the changes were made by the background agent. When opening Pull Requests, follow the required template and include all relevant sections: clearly state the scope of changes, the rationale for each change (e.g., "removed X because it was unused and causing confusion"), any potential risks or impact, and evidence of testing (such as "all tests and linters run locally and passed"). Include steps for rollback if applicable (even if it's as simple as reverting the commit). Affirm explicitly that there are no user-facing or behavior changes introduced by the PR (since this is a cleanup, it should not alter functionality). For example, add a note like "No functional changes – this PR is purely refactor/cleanup." Additionally, be mindful of ongoing work: avoid altering parts of the code that were changed very recently on other branches to minimize merge conflicts (coordinate with those changes if necessary). By following these conventions, the cleanup will integrate smoothly with our workflow and be easy to review and roll out.

APPROACH & EXECUTION
Approach this task systematically and thoroughly. Begin by scanning the repository and identifying problem areas in each of the categories above (testing, docs, dead code, etc.). Then address them one by one in a logical order – for instance, you might fix critical test failures or integration bugs before doing widespread formatting changes, to have a stable baseline. As you make changes, run the test suite and linters frequently to catch issues early. Do not introduce new features or change how the software behaves for end users. This entire exercise is a refactor/cleanup for maintainability and quality; everything should still work the same as before (only better internally). New code should only be added if absolutely necessary to improve tests or fix a bug uncovered during the audit, and not to add functionality. When you finish, all tests (including new ones you added) should be passing and coverage goals met, all linters/type-checkers should be clean, and the CI pipeline should be passing in full. The repository should be free of obvious technical debt, well-documented, and organized. In summary, don't be lazy or cursory – continue iterating until every item above is checked off and the codebase is in excellent shape. A task is not done until it has been completed to the best of your ability, resulting in a clean, robust codebase ready for Phase 2 development.

*DO NOT BE LAZY AND BUILD UP TECHNICAL DEBT. WORK ON PROBLEMS AS YOU SEE THEM.